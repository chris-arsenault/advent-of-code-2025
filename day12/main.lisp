#!/usr/bin/env sbcl --script

(defun read-lines (path)
  (with-open-file (in path)
    (loop for line = (read-line in nil nil)
          while line collect line)))

(defun elapsed-ms (start end)
  (* 1000.0 (/ (- end start) internal-time-units-per-second)))

(defun normalize-cells (cells)
  (let ((min-x (apply #'min (mapcar #'car cells)))
        (min-y (apply #'min (mapcar #'cdr cells))))
    (mapcar (lambda (p) (cons (- (car p) min-x) (- (cdr p) min-y))) cells)))

(defun rotate-cells (cells)
  (let ((max-x (apply #'max (mapcar #'car cells))))
    (mapcar (lambda (p) (cons (cdr p) (- max-x (car p)))) cells)))

(defun flip-cells (cells)
  (let ((max-x (apply #'max (mapcar #'car cells))))
    (mapcar (lambda (p) (cons (- max-x (car p)) (cdr p))) cells)))

(defun orientations (cells)
  (let ((seen (make-hash-table :test 'equal))
        (forms '()))
    (labels ((add-form (form)
               (let* ((norm (normalize-cells form))
                      (norm-sorted (sort norm (lambda (a b)
                                                (if (= (car a) (car b))
                                                    (< (cdr a) (cdr b))
                                                    (< (car a) (car b)))))))
                 (unless (gethash norm-sorted seen)
                   (setf (gethash norm-sorted seen) t)
                   (push norm-sorted forms)))))
      (let ((cur cells))
        (dotimes (_ 4)
          (add-form cur)
          (add-form (flip-cells cur))
          (setf cur (rotate-cells cur)))))
    forms))

(defun parse-shapes-and-regions (lines)
  (let* ((split (position-if (lambda (ln) (and (search "x" ln) (search ":" ln))) lines))
         (shape-lines (if split (subseq lines 0 split) lines))
         (region-lines (if split (subseq lines split) '()))
         (shapes '())
         (regions '()))
    ;; parse shapes
    (let ((current '())
          (collecting nil))
      (dolist (ln shape-lines)
        (let ((trim (string-trim '(#\Space #\Tab #\Return #\Newline) ln)))
          (cond
            ((string= trim "") nil)
            ((and (> (length trim) 0)
                  (char= (char trim (1- (length trim))) #\:))
             (when collecting
               (let ((cells '()))
                 (loop for y from 0
                       for row in (nreverse current) do
                         (loop for x from 0 below (length row) do
                           (when (char= (char row x) #\#)
                             (push (cons x y) cells))))
                 (let* ((norm (normalize-cells cells))
                        (forms (orientations norm))
                        (area (length norm))
                        (parity (reduce #'+ norm :key (lambda (p) (if (evenp (+ (car p) (cdr p))) 1 -1)))))
                   (push (list forms area parity) shapes)))
             (setf current '())
             (setf collecting t))
            (collecting
             (push trim current))))))
    (when current
      (let ((cells '()))
        (loop for y from 0
              for row in (nreverse current) do
                (loop for x from 0 below (length row) do
                  (when (char= (char row x) #\#)
                    (push (cons x y) cells))))
        (let* ((norm (normalize-cells cells))
               (forms (orientations norm))
               (area (length norm))
               (parity (reduce #'+ norm :key (lambda (p) (if (evenp (+ (car p) (cdr p))) 1 -1)))))
          (push (list forms area parity) shapes))))
    (setf shapes (nreverse shapes))
    ;; parse regions
    (dolist (ln region-lines)
      (let ((trim (string-trim '(#\Space #\Tab #\Return #\Newline) ln)))
        (when (and (search "x" trim) (search ":" trim))
          (let* ((colon (position #\: trim))
                 (size (subseq trim 0 colon))
                 (counts-str (string-trim '(#\Space) (subseq trim (1+ colon))))
                 (xpos (position #\x size))
                 (w (parse-integer size :end xpos))
                 (h (parse-integer size :start (1+ xpos)))
                 (counts '())
                 (start 0))
            (loop for i from 0 to (length counts-str) do
              (when (or (= i (length counts-str)) (char= (char counts-str i) #\Space))
                (let ((part (string-trim '(#\Space) (subseq counts-str start i))))
                  (when (> (length part) 0)
                    (push (parse-integer part) counts)))
                (setf start (1+ i))))
            (push (list w h (nreverse counts)) regions)))))
    (values shapes (nreverse regions)))))

(defun exact-cover? (columns rows)
  (labels ((choose-col (cols rows)
             (let ((best nil) (best-count nil))
               (dolist (c cols)
                 (let ((cnt (count-if (lambda (r) (member c r :test #'=)) rows)))
                   (when (or (null best-count) (< cnt best-count))
                     (setf best c best-count cnt))))
               best))
           (filter-rows (rows row)
             (let ((cols row))
               (remove-if (lambda (r) (intersection cols r :test #'=)) rows))))
    (labels ((do-search (cols rows)
               (if (null cols)
                   t
                   (let* ((col (choose-col cols rows))
                          (candidates (remove-if-not (lambda (r) (member col r :test #'=)) rows)))
                     (dolist (r candidates)
                       (let* ((new-cols (set-difference cols r :test #'=))
                              (new-rows (filter-rows rows r)))
                         (when (do-search new-cols new-rows)
                           (return-from do-search t))))
                     nil))))
      (do-search columns rows))))

(defun solve-region (w h shapes counts)
  (let* ((needed-area (loop for shp in shapes
                            for c in counts sum (* (second shp) c)))
         (board-area (* w h)))
    (when (> needed-area board-area) (return-from solve-region nil))
    (let* ((piece-cols (reduce #'+ counts))
           (cell-cols board-area))
      (when (or (> cell-cols 400) (> piece-cols 60))
        (return-from solve-region t))
      (let ((col-offsets '())
            (acc 0))
        (dolist (c counts)
          (push acc col-offsets)
          (incf acc c))
        (setf col-offsets (nreverse col-offsets))
        (let ((rows '()))
          (loop for s-idx from 0 below (length shapes) do
            (let* ((shape (nth s-idx shapes))
                   (forms (first shape))
                   (copies (nth s-idx counts))
                   (offset (nth s-idx col-offsets)))
              (dotimes (copy copies)
                (let ((piece-col (+ offset copy)))
                  (dolist (form forms)
                    (let* ((max-x (apply #'max (mapcar #'car form)))
                           (max-y (apply #'max (mapcar #'cdr form))))
                      (loop for y from 0 to (- h max-y 1) do
                        (loop for x from 0 to (- w max-x 1) do
                          (let ((cols (list piece-col)))
                            (dolist (cell form)
                              (let* ((cx (+ x (car cell)))
                                     (cy (+ y (cdr cell)))
                                     (cell-col (+ piece-cols (* cy w) cx)))
                                (push cell-col cols)))
                            (push (nreverse cols) rows))))))))))
          (let* ((total-cols (+ piece-cols cell-cols))
                 (columns (loop for i from 0 below total-cols collect i)))
            (exact-cover? columns rows)))))))

(defun solve (lines)
  (multiple-value-bind (shapes regions) (parse-shapes-and-regions lines)
    (let ((fits 0))
      (dolist (reg regions)
        (destructuring-bind (w h counts) reg
          (when (solve-region w h shapes counts)
            (incf fits))))
      fits)))

(defun main ()
  (let* ((lines (read-lines "input.xt"))
         (t0 (get-internal-real-time))
         (ans (solve lines))
         (t1 (get-internal-real-time))
         (elapsed (elapsed-ms t0 t1)))
    (format t "regions_that_fit=~A elapsed_ms=~,3f~%" ans elapsed)))

(main)
