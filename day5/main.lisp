#!/usr/bin/env sbcl --script

(defun read-file-string (path)
  (with-open-file (in path :direction :input :element-type 'character)
    (let* ((len (file-length in))
           (data (make-string len)))
      (read-sequence data in)
      data)))

(defun parse (text)
  (let ((top '())
        (bottom '())
        (in-bottom nil))
    (with-input-from-string (in text)
      (loop for line = (read-line in nil nil)
            while line do
              (let ((trim (string-trim '(#\Space #\Tab #\Return #\Newline) line)))
                (if (string= trim "")
                    (setf in-bottom t)
                    (if in-bottom
                        (push trim bottom)
                        (push trim top))))))
    (let ((ranges '())
          (ids '()))
      (dolist (line (nreverse top))
        (when (> (length line) 0)
          (let* ((dash (position #\- line))
                 (a (parse-integer line :end dash))
                 (b (parse-integer line :start (1+ dash))))
            (push (list a b) ranges))))
      (dolist (line (nreverse bottom))
        (when (> (length line) 0)
          (push (parse-integer line) ids)))
      (values (nreverse ranges) (nreverse ids)))))

;; Merge overlapping intervals using sort + reduce (idiomatic Lisp)
(defun merge-ranges (ranges)
  (let ((sorted (sort (copy-list ranges) #'< :key #'first)))
    (if (null sorted)
        '()
        (nreverse
         (reduce (lambda (merged rg)
                   (let ((a (first rg))
                         (b (second rg)))
                     (if (or (null merged)
                             (> a (1+ (second (first merged)))))
                         (cons (list a b) merged)
                         (progn
                           (setf (second (first merged))
                                 (max (second (first merged)) b))
                           merged))))
                 (cdr sorted)
                 :initial-value (list (first sorted)))))))

(defun in-any (ranges x)
  (let ((lo 0)
        (hi (length ranges)))
    (loop while (< lo hi) do
      (let* ((mid (ash (+ lo hi) -1))
             (rg (nth mid ranges))
             (a (first rg))
             (b (second rg)))
        (cond
          ((< x a) (setf hi mid))
          ((> x b) (setf lo (1+ mid)))
          (t (return-from in-any t)))))
    nil))

(defun solve (text)
  (multiple-value-bind (ranges ids) (parse text)
    (let* ((merged (merge-ranges ranges))
           (fresh (count-if (lambda (x) (in-any merged x)) ids))
           (total (reduce #'+ merged :key (lambda (rg) (1+ (- (second rg) (first rg)))))))
      (values fresh total))))

(defun main ()
  (let* ((start (get-internal-real-time))
         (text (read-file-string "input.txt"))
         (res (multiple-value-list (solve text)))
         (elapsed-ms (* 1000.0 (/ (- (get-internal-real-time) start)
                                  internal-time-units-per-second))))
    (destructuring-bind (p1 p2) res
      (format t "available_fresh=~A total_fresh_ids=~A elapsed_ms=~,3F~%" p1 p2 elapsed-ms))))

(main)
